/**
 * WARNING: This file was automatically generated by the Trading Hub tooling version 2.15.
 * Any manual changes may be overwritten and lost!
 */


// Generated from model_object_scala.erb

package com.trafigura.exceptions





import com.trafigura.tradinghub.support._
import scala.collection.JavaConversions._



/**
 The system model defines a series of objects that are generated as part of every output model, and provide standard
message types that are used in all deployments, regardless of actual message types.
The exposed processing exception has a number of special properties. It is for internal use only, so the codegen
can avoid generating some public-facing parts (samples for instance). For the most part, exceptions are also transient,
so auto-generated consumers should not create durable queues.
An exception that occurs whilst processing a message
 */


 class ProcessingException extends com.trafigura.tradinghub.support.ModelObject  {
  


  
    
    /**
     A machine readable code detailing the failure
     */

var code:String = null
    
    
    
    /**
     A human readable message detailing the failure
     */

var message:String = null
    
    
    
    /**
     The serialized body of the original message
     */

var original:String = null
    
    
    
    /**
     The application identifier for the contents of the original message
     */

var originalId:String = null
    
    
    
    /**
     The application identifier of the original caller
     */

var callerId:String = null
    
    





  override def equals(o: Any) = o match {
    case r: AnyRef =>
        if (o.isInstanceOf[com.trafigura.exceptions.ProcessingException]) {
            val that = r.asInstanceOf[com.trafigura.exceptions.ProcessingException]
            that.canEqual(this) && this.callerId == that.callerId && this.code == that.code && this.message == that.message && this.original == that.original && this.originalId == that.originalId &&  true
        }
        else false
    case _ => false
  }

  override def canEqual(that : Any) = that.isInstanceOf[com.trafigura.exceptions.ProcessingException]

  override def hashCode = {
    (41 * (41 * (41 * (41 * (41 *  1
    ) +
         (if (callerId == null) 0 else callerId.hashCode) 
    ) +
         (if (code == null) 0 else code.hashCode) 
    ) +
         (if (message == null) 0 else message.hashCode) 
    ) +
         (if (original == null) 0 else original.hashCode) 
    ) +
         (if (originalId == null) 0 else originalId.hashCode) 
    
  }

  override def toString = {
    "{com.trafigura.exceptions.ProcessingException: " + "" + "callerId = " + callerId + ", " + "code = " + code + ", " + "message = " + message + ", " + "original = " + original + ", " + "originalId = " + originalId +  "}"
  }


  
         def toJson() : org.codehaus.jettison.json.JSONObject = {
      toJson(new SerialisationHelper)
    }

     def toJson(differentiator: SerialisationHelper) : org.codehaus.jettison.json.JSONObject = {
        var result = new org.codehaus.jettison.json.JSONObject();

        result.put("_node", differentiator.idFor(this))

        result.put("Type", "Exceptions.Processing Exception@1@1.0")
        
          
          
          
          
            result.putOpt("Code", this.code);
          
        
          
          
          
          
            result.putOpt("Message", this.message);
          
        
          
          
          
          
            result.putOpt("Original", this.original);
          
        
          
          
          
          
            result.putOpt("OriginalId", this.originalId);
          
        
          
          
          
          
            result.putOpt("CallerId", this.callerId);
          
        
        return result;
    }

     def loadJson(jobj : org.codehaus.jettison.json.JSONObject, cache: DeserialisationHelper) = {
        
        
          
              code = JSONConversions.optional[String](jobj.opt("Code"), null)
          
              message = JSONConversions.optional[String](jobj.opt("Message"), null)
          
              original = JSONConversions.optional[String](jobj.opt("Original"), null)
          
              originalId = JSONConversions.optional[String](jobj.opt("OriginalId"), null)
          
              callerId = JSONConversions.optional[String](jobj.opt("CallerId"), null)
          
        
    }

  
}

object ProcessingException {
  def version = ModelVersion("1")
  def wireFormatVersion = ModelVersion("1.0")

  
        val jsonTypeName = "Exceptions.Processing Exception"

    def fromJson(jobj : org.codehaus.jettison.json.JSONObject, cache: DeserialisationHelper = new DeserialisationHelper) : com.trafigura.exceptions.ProcessingException = {
      val v = TypeHolder(jobj.optString("Type"))

      v.assertModelVersion(version, "com.trafigura.exceptions.ProcessingException")
      v.assertWireFormatVersion(wireFormatVersion, "com.trafigura.exceptions.ProcessingException")

      
        
            val result = new com.trafigura.exceptions.ProcessingException()
            result.loadJson(jobj, cache)
            result
        
      
    }

  

  

  
    def apply(code: String = null, message: String = null, original: String = null, originalId: String = null, callerId: String = null) = {
      val res = new com.trafigura.exceptions.ProcessingException
      
        res.code = code
      
        res.message = message
      
        res.original = original
      
        res.originalId = originalId
      
        res.callerId = callerId
      
      res
    }
  
}
