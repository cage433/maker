/**
 * WARNING: This file was automatically generated by the Trading Hub tooling version 2.15.
 * Any manual changes may be overwritten and lost!
 */


// Generated from model_object_scala.erb

package com.trafigura.edm.physicaltradespecs





import com.trafigura.tradinghub.support._
import scala.collection.JavaConversions._



/**
 A pricing specification determines a rule for calculating a price
in the context of some market data snapshot and a shipping month.

N.B. - This calculates a price, e.g. USD/MT - NOT a USD value.
The reason is that inventory items, quotas etc may all have the
same pricing specification - yet different prices and values.
 */


 abstract class PricingSpecification extends com.trafigura.tradinghub.support.ModelObject  {
  


  
    

var ordinal:Int = 0
    
    
    

var comments:String = null
    
    
    

var quantity:com.trafigura.edm.shared.types.Quantity = null
    
    
    
    /**
     If a pricing spec has a currency that is different to the associated market
then conversions will be done using ECB rate, unless there is an override.
Currency and fx overrides make no sense for anything other than unknown
and average pricing specs - however I'm not going to make the type hierarchy
any deeper
     */

var currency:com.trafigura.edm.shared.types.Currency = null
    
    
    

var fxOverrides:List[com.trafigura.edm.physicaltradespecs.FxOverride] = null
    
    





  override def equals(o: Any) = o match {
    case r: AnyRef =>
        if (o.isInstanceOf[com.trafigura.edm.physicaltradespecs.PricingSpecification]) {
            val that = r.asInstanceOf[com.trafigura.edm.physicaltradespecs.PricingSpecification]
            that.canEqual(this) && this.comments == that.comments && this.currency == that.currency && this.fxOverrides == that.fxOverrides && this.ordinal == that.ordinal && this.quantity == that.quantity &&  true
        }
        else false
    case _ => false
  }

  override def canEqual(that : Any) = that.isInstanceOf[com.trafigura.edm.physicaltradespecs.PricingSpecification]

  override def hashCode = {
    (41 * (41 * (41 * (41 * (41 *  1
    ) +
         (if (comments == null) 0 else comments.hashCode) 
    ) +
         (if (currency == null) 0 else currency.hashCode) 
    ) +
         (if (fxOverrides == null) 0 else fxOverrides.hashCode) 
    ) +
         ordinal.hashCode
        
    ) +
         (if (quantity == null) 0 else quantity.hashCode) 
    
  }

  override def toString = {
    "{com.trafigura.edm.physicaltradespecs.PricingSpecification: " + "" + "comments = " + comments + ", " + "currency = " + currency + ", " + "fxOverrides = " + fxOverrides + ", " + "ordinal = " + ordinal + ", " + "quantity = " + quantity +  "}"
  }


  
         def toJson() : org.codehaus.jettison.json.JSONObject = {
      toJson(new SerialisationHelper)
    }

     def toJson(differentiator: SerialisationHelper) : org.codehaus.jettison.json.JSONObject = {
        var result = new org.codehaus.jettison.json.JSONObject();

        result.put("_node", differentiator.idFor(this))

        result.put("Type", "EDM.PhysicalTradeSpecs.PricingSpecification@1@1.0")
        
          
          
          
          
            result.putOpt("Ordinal", this.ordinal);
          
        
          
          
          
          
            result.putOpt("Comments", this.comments);
          
        
          
          
          
          
            result.putOpt("Quantity", (this.quantity) match { case null => null; case o => o.toJson(differentiator) });
          
        
          
          
          
          
            result.putOpt("Currency", (this.currency) match { case null => null; case o => o.toJson(differentiator) });
          
        
          
          
          
          
            result.putOpt("FxOverrides", new org.codehaus.jettison.json.JSONArray(if(this.fxOverrides == null) new java.util.ArrayList() else java.util.Arrays.asList(this.fxOverrides.map(t => (t) match { case null => null; case o => o.toJson(differentiator) }).toArray: _*)));
          
        
        return result;
    }

     def loadJson(jobj : org.codehaus.jettison.json.JSONObject, cache: DeserialisationHelper) = {
        
        
          
              ordinal = JSONConversions.optional[Int](jobj.opt("Ordinal"), 0)
          
              comments = JSONConversions.optional[String](jobj.opt("Comments"), null)
          
              quantity = (jobj.opt("Quantity")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.edm.shared.types.Quantity.fromJson(o, cache))) }
          
              currency = (jobj.opt("Currency")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.edm.shared.types.Currency.fromJson(o, cache))) }
          
              fxOverrides = JSONConversions.optionalList(jobj.opt("FxOverrides"), x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.edm.physicaltradespecs.FxOverride.fromJson(o, cache))) })
          
        
    }

  
}

object PricingSpecification {
  def version = ModelVersion("1")
  def wireFormatVersion = ModelVersion("1.0")

  
        val jsonTypeName = "EDM.PhysicalTradeSpecs.PricingSpecification"

    def fromJson(jobj : org.codehaus.jettison.json.JSONObject, cache: DeserialisationHelper = new DeserialisationHelper) : com.trafigura.edm.physicaltradespecs.PricingSpecification = {
      val v = TypeHolder(jobj.optString("Type"))

      v.assertModelVersion(version, "com.trafigura.edm.physicaltradespecs.PricingSpecification")
      v.assertWireFormatVersion(wireFormatVersion, "com.trafigura.edm.physicaltradespecs.PricingSpecification")

      
        
              v.typeName match {
              
                case "EDM.PhysicalTradeSpecs.FixedPricingSpecification" =>
                  
                     val result = new com.trafigura.edm.physicaltradespecs.FixedPricingSpecification()
                     result.loadJson(jobj, cache)
                     result
                  
              
                case "EDM.PhysicalTradeSpecs.UnknownPricingSpecification" =>
                  
                     val result = new com.trafigura.edm.physicaltradespecs.UnknownPricingSpecification()
                     result.loadJson(jobj, cache)
                     result
                  
              
                case "EDM.PhysicalTradeSpecs.AveragePricingSpecification" =>
                  
                     val result = new com.trafigura.edm.physicaltradespecs.AveragePricingSpecification()
                     result.loadJson(jobj, cache)
                     result
                  
              
                case "EDM.PhysicalTradeSpecs.MonthAveragePricingSpecification" =>
                  
                     val result = new com.trafigura.edm.physicaltradespecs.MonthAveragePricingSpecification()
                     result.loadJson(jobj, cache)
                     result
                  
              
                case "EDM.PhysicalTradeSpecs.PartialAveragePricingSpecification" =>
                  
                     val result = new com.trafigura.edm.physicaltradespecs.PartialAveragePricingSpecification()
                     result.loadJson(jobj, cache)
                     result
                  
              
                case "EDM.PhysicalTradeSpecs.WeightedPricingSpecification" =>
                  
                     val result = new com.trafigura.edm.physicaltradespecs.WeightedPricingSpecification()
                     result.loadJson(jobj, cache)
                     result
                  
              
                case _ =>
                  
                    throw new RuntimeException("Tried to instantiate abstract class  com.trafigura.edm.physicaltradespecs.PricingSpecification. Type name was "+v.typeName)
                  
            }
        
      
    }

  

  
  val CommentLength = 4000
  

  
}
