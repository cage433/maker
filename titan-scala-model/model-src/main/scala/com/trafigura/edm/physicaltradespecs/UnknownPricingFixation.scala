/**
 * WARNING: This file was automatically generated by the Trading Hub tooling version 2.15.
 * Any manual changes may be overwritten and lost!
 */


// Generated from model_object_scala.erb

package com.trafigura.edm.physicaltradespecs





import com.trafigura.tradinghub.support._
import scala.collection.JavaConversions._



/**
 Some trades have their price fixed by one party exercising their right
to fix a price using the 'observed' market price during the shipping
month (or some offset to it), with some premium added.
There will be one or more such exercises,until the entire quota is fixed
Note that these may be negative as 'unfixings' occur when the
counterparty uses this mechanism to punt.
 */


 class UnknownPricingFixation extends com.trafigura.tradinghub.support.ModelObject  {
  


  
    

var fixedQuantity:com.trafigura.edm.shared.types.Quantity = null
    
    
    
    /**
     Note that this is the market price - the premium
     */

var observedPrice:com.trafigura.edm.shared.types.Quantity = null
    
    





  override def equals(o: Any) = o match {
    case r: AnyRef =>
        if (o.isInstanceOf[com.trafigura.edm.physicaltradespecs.UnknownPricingFixation]) {
            val that = r.asInstanceOf[com.trafigura.edm.physicaltradespecs.UnknownPricingFixation]
            that.canEqual(this) && this.fixedQuantity == that.fixedQuantity && this.observedPrice == that.observedPrice &&  true
        }
        else false
    case _ => false
  }

  override def canEqual(that : Any) = that.isInstanceOf[com.trafigura.edm.physicaltradespecs.UnknownPricingFixation]

  override def hashCode = {
    (41 * (41 *  1
    ) +
         (if (fixedQuantity == null) 0 else fixedQuantity.hashCode) 
    ) +
         (if (observedPrice == null) 0 else observedPrice.hashCode) 
    
  }

  override def toString = {
    "{com.trafigura.edm.physicaltradespecs.UnknownPricingFixation: " + "" + "fixedQuantity = " + fixedQuantity + ", " + "observedPrice = " + observedPrice +  "}"
  }


  
         def toJson() : org.codehaus.jettison.json.JSONObject = {
      toJson(new SerialisationHelper)
    }

     def toJson(differentiator: SerialisationHelper) : org.codehaus.jettison.json.JSONObject = {
        var result = new org.codehaus.jettison.json.JSONObject();

        result.put("_node", differentiator.idFor(this))

        result.put("Type", "EDM.PhysicalTradeSpecs.UnknownPricingFixation@1@1.0")
        
          
          
          
          
            result.putOpt("FixedQuantity", (this.fixedQuantity) match { case null => null; case o => o.toJson(differentiator) });
          
        
          
          
          
          
            result.putOpt("ObservedPrice", (this.observedPrice) match { case null => null; case o => o.toJson(differentiator) });
          
        
        return result;
    }

     def loadJson(jobj : org.codehaus.jettison.json.JSONObject, cache: DeserialisationHelper) = {
        
        
          
              fixedQuantity = (jobj.opt("FixedQuantity")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.edm.shared.types.Quantity.fromJson(o, cache))) }
          
              observedPrice = (jobj.opt("ObservedPrice")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.edm.shared.types.Quantity.fromJson(o, cache))) }
          
        
    }

  
}

object UnknownPricingFixation {
  def version = ModelVersion("1")
  def wireFormatVersion = ModelVersion("1.0")

  
        val jsonTypeName = "EDM.PhysicalTradeSpecs.UnknownPricingFixation"

    def fromJson(jobj : org.codehaus.jettison.json.JSONObject, cache: DeserialisationHelper = new DeserialisationHelper) : com.trafigura.edm.physicaltradespecs.UnknownPricingFixation = {
      val v = TypeHolder(jobj.optString("Type"))

      v.assertModelVersion(version, "com.trafigura.edm.physicaltradespecs.UnknownPricingFixation")
      v.assertWireFormatVersion(wireFormatVersion, "com.trafigura.edm.physicaltradespecs.UnknownPricingFixation")

      
        
            val result = new com.trafigura.edm.physicaltradespecs.UnknownPricingFixation()
            result.loadJson(jobj, cache)
            result
        
      
    }

  

  

  
    def apply(fixedQuantity: com.trafigura.edm.shared.types.Quantity = null, observedPrice: com.trafigura.edm.shared.types.Quantity = null) = {
      val res = new com.trafigura.edm.physicaltradespecs.UnknownPricingFixation
      
        res.fixedQuantity = fixedQuantity
      
        res.observedPrice = observedPrice
      
      res
    }
  
}
