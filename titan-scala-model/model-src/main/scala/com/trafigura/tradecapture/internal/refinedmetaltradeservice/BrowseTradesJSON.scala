/**
 * WARNING: This file was automatically generated by the Trading Hub tooling version 2.15.
 * Any manual changes may be overwritten and lost!
 */


// Generated from model_service_json.rb

package com.trafigura.tradecapture.internal.refinedmetaltradeservice

import com.trafigura.tradecapture.internal.refinedmetal._
import com.trafigura.tradecapture.internal.refinedmetaltradeservice._
import com.trafigura.edm.shared.types._

import org.codehaus.jettison.json.JSONObject
import com.trafigura.tradinghub.support._

// JSON support for BrowseTrades

object BrowseTradesJSON extends JSONServiceDispatcher[BrowseTrades] {
  def serviceName = "TradeCapture.Internal.RefinedMetalTradeService.BrowseTrades"

  def decodeOperationName(jsonName:String) = {
    jsonName match {
      case "GetTradeBlotterRowById" => "GetTradeBlotterRowById"
      case "GetTradeBlotterRowByTitanId" => "GetTradeBlotterRowByTitanId"
      case "GetFilteredTradeBlotterRowById" => "GetFilteredTradeBlotterRowById"
      case "GetFilteredTradeBlotterRowByTitanId" => "GetFilteredTradeBlotterRowByTitanId"
      case "GetNotCancelledTradeBlotterRows" => "GetNotCancelledTradeBlotterRows"
      case "GetNotCancelledTradeBlotterRowsFromId" => "GetNotCancelledTradeBlotterRowsFromId"
      case "GetNotCancelledTradeBlotterRowsFromTitanId" => "GetNotCancelledTradeBlotterRowsFromTitanId"
      case "GetFilteredNotCancelledTradeBlotterRowsFromId" => "GetFilteredNotCancelledTradeBlotterRowsFromId"
      case "GetFilteredNotCancelledTradeBlotterRowsFromTitanId" => "GetFilteredNotCancelledTradeBlotterRowsFromTitanId"
      case "GetTradeBlotterQuotaRowsForTrade" => "GetTradeBlotterQuotaRowsForTrade"
      case "GetTradeBlotterQuotaRowsForTradeByTitanId" => "GetTradeBlotterQuotaRowsForTradeByTitanId"
      case "CheckTradeWithIdExists" => "CheckTradeWithIdExists"
      case "CheckTradeWithTitanIdExists" => "CheckTradeWithTitanIdExists"
      case "CheckTradeWithNeptuneIdExists" => "CheckTradeWithNeptuneIdExists"
      
    }
  }

  def parseParameters(operation:String, params: JSONObject) = {
    operation match {
      
      case "GetTradeBlotterRowById" =>
        
          val cache = new DeserialisationHelper
          Map("oid" -> (JSONConversions.optional[Int](params.opt("Oid"), 0)))
        
      
      case "GetTradeBlotterRowByTitanId" =>
        
          val cache = new DeserialisationHelper
          Map("titanId" -> ((params.opt("TitanId")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.edm.shared.types.TitanId.fromJson(o, cache))) }))
        
      
      case "GetFilteredTradeBlotterRowById" =>
        
          val cache = new DeserialisationHelper
          Map("filterByWho" -> (JSONConversions.optional[Int](params.opt("FilterByWho"), 0)), "filterByDate" -> (JSONConversions.optional[Int](params.opt("FilterByDate"), 0)), "oid" -> (JSONConversions.optional[Int](params.opt("Oid"), 0)))
        
      
      case "GetFilteredTradeBlotterRowByTitanId" =>
        
          val cache = new DeserialisationHelper
          Map("filterByWho" -> (JSONConversions.optional[Int](params.opt("FilterByWho"), 0)), "filterByDate" -> (JSONConversions.optional[Int](params.opt("FilterByDate"), 0)), "titanId" -> ((params.opt("TitanId")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.edm.shared.types.TitanId.fromJson(o, cache))) }))
        
      
      case "GetNotCancelledTradeBlotterRows" =>
        
          Map()
        
      
      case "GetNotCancelledTradeBlotterRowsFromId" =>
        
          val cache = new DeserialisationHelper
          Map("id" -> (JSONConversions.optional[Int](params.opt("Id"), 0)), "count" -> (JSONConversions.optional[Int](params.opt("Count"), 0)))
        
      
      case "GetNotCancelledTradeBlotterRowsFromTitanId" =>
        
          val cache = new DeserialisationHelper
          Map("titanId" -> ((params.opt("TitanId")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.edm.shared.types.TitanId.fromJson(o, cache))) }), "count" -> (JSONConversions.optional[Int](params.opt("Count"), 0)))
        
      
      case "GetFilteredNotCancelledTradeBlotterRowsFromId" =>
        
          val cache = new DeserialisationHelper
          Map("filterByWho" -> (JSONConversions.optional[Int](params.opt("FilterByWho"), 0)), "filterByDate" -> (JSONConversions.optional[Int](params.opt("FilterByDate"), 0)), "id" -> (JSONConversions.optional[Int](params.opt("Id"), 0)), "count" -> (JSONConversions.optional[Int](params.opt("Count"), 0)))
        
      
      case "GetFilteredNotCancelledTradeBlotterRowsFromTitanId" =>
        
          val cache = new DeserialisationHelper
          Map("filterByWho" -> (JSONConversions.optional[Int](params.opt("FilterByWho"), 0)), "filterByDate" -> (JSONConversions.optional[Int](params.opt("FilterByDate"), 0)), "titanId" -> ((params.opt("TitanId")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.edm.shared.types.TitanId.fromJson(o, cache))) }), "count" -> (JSONConversions.optional[Int](params.opt("Count"), 0)))
        
      
      case "GetTradeBlotterQuotaRowsForTrade" =>
        
          val cache = new DeserialisationHelper
          Map("oid" -> (JSONConversions.optional[Int](params.opt("Oid"), 0)), "sortBy" -> (JSONConversions.optional[String](params.opt("SortBy"), null)))
        
      
      case "GetTradeBlotterQuotaRowsForTradeByTitanId" =>
        
          val cache = new DeserialisationHelper
          Map("titanId" -> ((params.opt("TitanId")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.edm.shared.types.TitanId.fromJson(o, cache))) }), "sortBy" -> (JSONConversions.optional[String](params.opt("SortBy"), null)))
        
      
      case "CheckTradeWithIdExists" =>
        
          val cache = new DeserialisationHelper
          Map("oid" -> (JSONConversions.optional[Int](params.opt("Oid"), 0)))
        
      
      case "CheckTradeWithTitanIdExists" =>
        
          val cache = new DeserialisationHelper
          Map("titanId" -> ((params.opt("TitanId")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.edm.shared.types.TitanId.fromJson(o, cache))) }))
        
      
      case "CheckTradeWithNeptuneIdExists" =>
        
          val cache = new DeserialisationHelper
          Map("neptuneId" -> (JSONConversions.optional[String](params.opt("NeptuneId"), null)))
        
      
    }
  }

  def invoke(target: BrowseTrades, operation: String, params: Map[String, Any]): Any = {
    operation match {
      
      case "GetTradeBlotterRowById" =>
        target.getTradeBlotterRowById(params("oid").asInstanceOf[Int])
      
      case "GetTradeBlotterRowByTitanId" =>
        target.getTradeBlotterRowByTitanId(params("titanId").asInstanceOf[com.trafigura.edm.shared.types.TitanId])
      
      case "GetFilteredTradeBlotterRowById" =>
        target.getFilteredTradeBlotterRowById(params("filterByWho").asInstanceOf[Int], params("filterByDate").asInstanceOf[Int], params("oid").asInstanceOf[Int])
      
      case "GetFilteredTradeBlotterRowByTitanId" =>
        target.getFilteredTradeBlotterRowByTitanId(params("filterByWho").asInstanceOf[Int], params("filterByDate").asInstanceOf[Int], params("titanId").asInstanceOf[com.trafigura.edm.shared.types.TitanId])
      
      case "GetNotCancelledTradeBlotterRows" =>
        target.getNotCancelledTradeBlotterRows()
      
      case "GetNotCancelledTradeBlotterRowsFromId" =>
        target.getNotCancelledTradeBlotterRowsFromId(params("id").asInstanceOf[Int], params("count").asInstanceOf[Int])
      
      case "GetNotCancelledTradeBlotterRowsFromTitanId" =>
        target.getNotCancelledTradeBlotterRowsFromTitanId(params("titanId").asInstanceOf[com.trafigura.edm.shared.types.TitanId], params("count").asInstanceOf[Int])
      
      case "GetFilteredNotCancelledTradeBlotterRowsFromId" =>
        target.getFilteredNotCancelledTradeBlotterRowsFromId(params("filterByWho").asInstanceOf[Int], params("filterByDate").asInstanceOf[Int], params("id").asInstanceOf[Int], params("count").asInstanceOf[Int])
      
      case "GetFilteredNotCancelledTradeBlotterRowsFromTitanId" =>
        target.getFilteredNotCancelledTradeBlotterRowsFromTitanId(params("filterByWho").asInstanceOf[Int], params("filterByDate").asInstanceOf[Int], params("titanId").asInstanceOf[com.trafigura.edm.shared.types.TitanId], params("count").asInstanceOf[Int])
      
      case "GetTradeBlotterQuotaRowsForTrade" =>
        target.getTradeBlotterQuotaRowsForTrade(params("oid").asInstanceOf[Int], params("sortBy").asInstanceOf[String])
      
      case "GetTradeBlotterQuotaRowsForTradeByTitanId" =>
        target.getTradeBlotterQuotaRowsForTradeByTitanId(params("titanId").asInstanceOf[com.trafigura.edm.shared.types.TitanId], params("sortBy").asInstanceOf[String])
      
      case "CheckTradeWithIdExists" =>
        target.checkTradeWithIdExists(params("oid").asInstanceOf[Int])
      
      case "CheckTradeWithTitanIdExists" =>
        target.checkTradeWithTitanIdExists(params("titanId").asInstanceOf[com.trafigura.edm.shared.types.TitanId])
      
      case "CheckTradeWithNeptuneIdExists" =>
        target.checkTradeWithNeptuneIdExists(params("neptuneId").asInstanceOf[String])
      
    }
  }

  def addResponse(operation:String, jsonResponse:JSONObject, response:Any) = {
    val differentiator = new SerialisationHelper
    operation match {
      
      case "GetTradeBlotterRowById" =>
        jsonResponse.putOpt("result", (response.asInstanceOf[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]) match { case null => null; case o => o.toJson(differentiator) })
      
      case "GetTradeBlotterRowByTitanId" =>
        jsonResponse.putOpt("result", (response.asInstanceOf[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]) match { case null => null; case o => o.toJson(differentiator) })
      
      case "GetFilteredTradeBlotterRowById" =>
        jsonResponse.putOpt("result", (response.asInstanceOf[com.trafigura.tradecapture.internal.refinedmetaltradeservice.FilteredTradeBlotterRowResults]) match { case null => null; case o => o.toJson(differentiator) })
      
      case "GetFilteredTradeBlotterRowByTitanId" =>
        jsonResponse.putOpt("result", (response.asInstanceOf[com.trafigura.tradecapture.internal.refinedmetaltradeservice.FilteredTradeBlotterRowResults]) match { case null => null; case o => o.toJson(differentiator) })
      
      case "GetNotCancelledTradeBlotterRows" =>
        jsonResponse.putOpt("result", new org.codehaus.jettison.json.JSONArray(if(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]] == null) new java.util.ArrayList() else java.util.Arrays.asList(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]].map(t => (t) match { case null => null; case o => o.toJson(differentiator) }).toArray: _*)))
      
      case "GetNotCancelledTradeBlotterRowsFromId" =>
        jsonResponse.putOpt("result", new org.codehaus.jettison.json.JSONArray(if(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]] == null) new java.util.ArrayList() else java.util.Arrays.asList(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]].map(t => (t) match { case null => null; case o => o.toJson(differentiator) }).toArray: _*)))
      
      case "GetNotCancelledTradeBlotterRowsFromTitanId" =>
        jsonResponse.putOpt("result", new org.codehaus.jettison.json.JSONArray(if(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]] == null) new java.util.ArrayList() else java.util.Arrays.asList(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]].map(t => (t) match { case null => null; case o => o.toJson(differentiator) }).toArray: _*)))
      
      case "GetFilteredNotCancelledTradeBlotterRowsFromId" =>
        jsonResponse.putOpt("result", new org.codehaus.jettison.json.JSONArray(if(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]] == null) new java.util.ArrayList() else java.util.Arrays.asList(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]].map(t => (t) match { case null => null; case o => o.toJson(differentiator) }).toArray: _*)))
      
      case "GetFilteredNotCancelledTradeBlotterRowsFromTitanId" =>
        jsonResponse.putOpt("result", new org.codehaus.jettison.json.JSONArray(if(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]] == null) new java.util.ArrayList() else java.util.Arrays.asList(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]].map(t => (t) match { case null => null; case o => o.toJson(differentiator) }).toArray: _*)))
      
      case "GetTradeBlotterQuotaRowsForTrade" =>
        jsonResponse.putOpt("result", new org.codehaus.jettison.json.JSONArray(if(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow]] == null) new java.util.ArrayList() else java.util.Arrays.asList(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow]].map(t => (t) match { case null => null; case o => o.toJson(differentiator) }).toArray: _*)))
      
      case "GetTradeBlotterQuotaRowsForTradeByTitanId" =>
        jsonResponse.putOpt("result", new org.codehaus.jettison.json.JSONArray(if(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow]] == null) new java.util.ArrayList() else java.util.Arrays.asList(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow]].map(t => (t) match { case null => null; case o => o.toJson(differentiator) }).toArray: _*)))
      
      case "CheckTradeWithIdExists" =>
        jsonResponse.putOpt("result", response.asInstanceOf[Boolean])
      
      case "CheckTradeWithTitanIdExists" =>
        jsonResponse.putOpt("result", response.asInstanceOf[Boolean])
      
      case "CheckTradeWithNeptuneIdExists" =>
        jsonResponse.putOpt("result", response.asInstanceOf[Boolean])
      
    }
  }

  
  def serializeGetTradeBlotterRowById(oid: Int): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("Oid", oid)
    
    params
  }
  
  def serializeGetTradeBlotterRowByTitanId(titanId: com.trafigura.edm.shared.types.TitanId): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("TitanId", (titanId) match { case null => null; case o => o.toJson(differentiator) })
    
    params
  }
  
  def serializeGetFilteredTradeBlotterRowById(filterByWho: Int, filterByDate: Int, oid: Int): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("FilterByWho", filterByWho)
    
      params.putOpt("FilterByDate", filterByDate)
    
      params.putOpt("Oid", oid)
    
    params
  }
  
  def serializeGetFilteredTradeBlotterRowByTitanId(filterByWho: Int, filterByDate: Int, titanId: com.trafigura.edm.shared.types.TitanId): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("FilterByWho", filterByWho)
    
      params.putOpt("FilterByDate", filterByDate)
    
      params.putOpt("TitanId", (titanId) match { case null => null; case o => o.toJson(differentiator) })
    
    params
  }
  
  def serializeGetNotCancelledTradeBlotterRows(): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
    params
  }
  
  def serializeGetNotCancelledTradeBlotterRowsFromId(identifier: Int, count: Int): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("Id", identifier)
    
      params.putOpt("Count", count)
    
    params
  }
  
  def serializeGetNotCancelledTradeBlotterRowsFromTitanId(titanId: com.trafigura.edm.shared.types.TitanId, count: Int): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("TitanId", (titanId) match { case null => null; case o => o.toJson(differentiator) })
    
      params.putOpt("Count", count)
    
    params
  }
  
  def serializeGetFilteredNotCancelledTradeBlotterRowsFromId(filterByWho: Int, filterByDate: Int, identifier: Int, count: Int): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("FilterByWho", filterByWho)
    
      params.putOpt("FilterByDate", filterByDate)
    
      params.putOpt("Id", identifier)
    
      params.putOpt("Count", count)
    
    params
  }
  
  def serializeGetFilteredNotCancelledTradeBlotterRowsFromTitanId(filterByWho: Int, filterByDate: Int, titanId: com.trafigura.edm.shared.types.TitanId, count: Int): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("FilterByWho", filterByWho)
    
      params.putOpt("FilterByDate", filterByDate)
    
      params.putOpt("TitanId", (titanId) match { case null => null; case o => o.toJson(differentiator) })
    
      params.putOpt("Count", count)
    
    params
  }
  
  def serializeGetTradeBlotterQuotaRowsForTrade(oid: Int, sortBy: String): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("Oid", oid)
    
      params.putOpt("SortBy", sortBy)
    
    params
  }
  
  def serializeGetTradeBlotterQuotaRowsForTradeByTitanId(titanId: com.trafigura.edm.shared.types.TitanId, sortBy: String): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("TitanId", (titanId) match { case null => null; case o => o.toJson(differentiator) })
    
      params.putOpt("SortBy", sortBy)
    
    params
  }
  
  def serializeCheckTradeWithIdExists(oid: Int): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("Oid", oid)
    
    params
  }
  
  def serializeCheckTradeWithTitanIdExists(titanId: com.trafigura.edm.shared.types.TitanId): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("TitanId", (titanId) match { case null => null; case o => o.toJson(differentiator) })
    
    params
  }
  
  def serializeCheckTradeWithNeptuneIdExists(neptuneId: String): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("NeptuneId", neptuneId)
    
    params
  }
  

  class Proxy(val handler: (String, JSONObject) => JSONObject) extends BrowseTrades {
  
    def getTradeBlotterRowById(oid: Int): com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow = {
        val request = new JSONObject
        request.put("method", "GetTradeBlotterRowById")
        
        request.put("params", serializeGetTradeBlotterRowById(oid))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          (response.opt("result")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) }
        }
    }
  
    def getTradeBlotterRowByTitanId(titanId: com.trafigura.edm.shared.types.TitanId): com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow = {
        val request = new JSONObject
        request.put("method", "GetTradeBlotterRowByTitanId")
        
        request.put("params", serializeGetTradeBlotterRowByTitanId(titanId))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          (response.opt("result")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) }
        }
    }
  
    def getFilteredTradeBlotterRowById(filterByWho: Int, filterByDate: Int, oid: Int): com.trafigura.tradecapture.internal.refinedmetaltradeservice.FilteredTradeBlotterRowResults = {
        val request = new JSONObject
        request.put("method", "GetFilteredTradeBlotterRowById")
        
        request.put("params", serializeGetFilteredTradeBlotterRowById(filterByWho, filterByDate, oid))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[com.trafigura.tradecapture.internal.refinedmetaltradeservice.FilteredTradeBlotterRowResults]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          (response.opt("result")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetaltradeservice.FilteredTradeBlotterRowResults.fromJson(o, cache))) }
        }
    }
  
    def getFilteredTradeBlotterRowByTitanId(filterByWho: Int, filterByDate: Int, titanId: com.trafigura.edm.shared.types.TitanId): com.trafigura.tradecapture.internal.refinedmetaltradeservice.FilteredTradeBlotterRowResults = {
        val request = new JSONObject
        request.put("method", "GetFilteredTradeBlotterRowByTitanId")
        
        request.put("params", serializeGetFilteredTradeBlotterRowByTitanId(filterByWho, filterByDate, titanId))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[com.trafigura.tradecapture.internal.refinedmetaltradeservice.FilteredTradeBlotterRowResults]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          (response.opt("result")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetaltradeservice.FilteredTradeBlotterRowResults.fromJson(o, cache))) }
        }
    }
  
    def getNotCancelledTradeBlotterRows(): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow] = {
        val request = new JSONObject
        request.put("method", "GetNotCancelledTradeBlotterRows")
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(response.opt("result"), x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) })
        }
    }
  
    def getNotCancelledTradeBlotterRowsFromId(identifier: Int, count: Int): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow] = {
        val request = new JSONObject
        request.put("method", "GetNotCancelledTradeBlotterRowsFromId")
        
        request.put("params", serializeGetNotCancelledTradeBlotterRowsFromId(identifier, count))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(response.opt("result"), x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) })
        }
    }
  
    def getNotCancelledTradeBlotterRowsFromTitanId(titanId: com.trafigura.edm.shared.types.TitanId, count: Int): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow] = {
        val request = new JSONObject
        request.put("method", "GetNotCancelledTradeBlotterRowsFromTitanId")
        
        request.put("params", serializeGetNotCancelledTradeBlotterRowsFromTitanId(titanId, count))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(response.opt("result"), x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) })
        }
    }
  
    def getFilteredNotCancelledTradeBlotterRowsFromId(filterByWho: Int, filterByDate: Int, identifier: Int, count: Int): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow] = {
        val request = new JSONObject
        request.put("method", "GetFilteredNotCancelledTradeBlotterRowsFromId")
        
        request.put("params", serializeGetFilteredNotCancelledTradeBlotterRowsFromId(filterByWho, filterByDate, identifier, count))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(response.opt("result"), x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) })
        }
    }
  
    def getFilteredNotCancelledTradeBlotterRowsFromTitanId(filterByWho: Int, filterByDate: Int, titanId: com.trafigura.edm.shared.types.TitanId, count: Int): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow] = {
        val request = new JSONObject
        request.put("method", "GetFilteredNotCancelledTradeBlotterRowsFromTitanId")
        
        request.put("params", serializeGetFilteredNotCancelledTradeBlotterRowsFromTitanId(filterByWho, filterByDate, titanId, count))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow]]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(response.opt("result"), x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) })
        }
    }
  
    def getTradeBlotterQuotaRowsForTrade(oid: Int, sortBy: String): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow] = {
        val request = new JSONObject
        request.put("method", "GetTradeBlotterQuotaRowsForTrade")
        
        request.put("params", serializeGetTradeBlotterQuotaRowsForTrade(oid, sortBy))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow]]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(response.opt("result"), x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow.fromJson(o, cache))) })
        }
    }
  
    def getTradeBlotterQuotaRowsForTradeByTitanId(titanId: com.trafigura.edm.shared.types.TitanId, sortBy: String): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow] = {
        val request = new JSONObject
        request.put("method", "GetTradeBlotterQuotaRowsForTradeByTitanId")
        
        request.put("params", serializeGetTradeBlotterQuotaRowsForTradeByTitanId(titanId, sortBy))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow]]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(response.opt("result"), x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow.fromJson(o, cache))) })
        }
    }
  
    def checkTradeWithIdExists(oid: Int): Boolean = {
        val request = new JSONObject
        request.put("method", "CheckTradeWithIdExists")
        
        request.put("params", serializeCheckTradeWithIdExists(oid))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[Boolean]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optional[Boolean](response.opt("result"), false)
        }
    }
  
    def checkTradeWithTitanIdExists(titanId: com.trafigura.edm.shared.types.TitanId): Boolean = {
        val request = new JSONObject
        request.put("method", "CheckTradeWithTitanIdExists")
        
        request.put("params", serializeCheckTradeWithTitanIdExists(titanId))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[Boolean]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optional[Boolean](response.opt("result"), false)
        }
    }
  
    def checkTradeWithNeptuneIdExists(neptuneId: String): Boolean = {
        val request = new JSONObject
        request.put("method", "CheckTradeWithNeptuneIdExists")
        
        request.put("params", serializeCheckTradeWithNeptuneIdExists(neptuneId))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[Boolean]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optional[Boolean](response.opt("result"), false)
        }
    }
  
  }
}

