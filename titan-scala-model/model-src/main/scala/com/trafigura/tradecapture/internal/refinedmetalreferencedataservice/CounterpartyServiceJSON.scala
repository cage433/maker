/**
 * WARNING: This file was automatically generated by the Trading Hub tooling version 2.15.
 * Any manual changes may be overwritten and lost!
 */


// Generated from model_service_json.rb

package com.trafigura.tradecapture.internal.refinedmetalreferencedataservice

import com.trafigura.tradecapture.internal.refinedmetal._

import org.codehaus.jettison.json.JSONObject
import com.trafigura.tradinghub.support._

// JSON support for CounterpartyService

object CounterpartyServiceJSON extends JSONServiceDispatcher[CounterpartyService] {
  def serviceName = "TradeCapture.Internal.RefinedMetalReferenceDataService.CounterpartyService"

  def decodeOperationName(jsonName:String) = {
    jsonName match {
      case "CreateNonKYCCounterparty" => "CreateNonKYCCounterparty"
      case "UpdateNonKYCCounterparty" => "UpdateNonKYCCounterparty"
      case "GetNonKYCCounterparty" => "GetNonKYCCounterparty"
      case "CheckNonKYCCounterpartyExists" => "CheckNonKYCCounterpartyExists"
      case "CheckNonKYCCounterpartyExistsForGroupCompany" => "CheckNonKYCCounterpartyExistsForGroupCompany"
      case "GetCounterpartyForCode" => "GetCounterpartyForCode"
      case "GetCounterparties" => "GetCounterparties"
      case "GetCounterpartiesForGroupCompany" => "GetCounterpartiesForGroupCompany"
      
    }
  }

  def parseParameters(operation:String, params: JSONObject) = {
    operation match {
      
      case "CreateNonKYCCounterparty" =>
        
          val cache = new DeserialisationHelper
          Map("nonKYCCounterParty" -> ((params.opt("NonKYCCounterParty")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.NonKYCCounterparty.fromJson(o, cache))) }))
        
      
      case "UpdateNonKYCCounterparty" =>
        
          val cache = new DeserialisationHelper
          Map("nonKYCCounterParty" -> ((params.opt("NonKYCCounterParty")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.NonKYCCounterparty.fromJson(o, cache))) }))
        
      
      case "GetNonKYCCounterparty" =>
        
          val cache = new DeserialisationHelper
          Map("oid" -> (JSONConversions.optional[Int](params.opt("Oid"), 0)))
        
      
      case "CheckNonKYCCounterpartyExists" =>
        
          val cache = new DeserialisationHelper
          Map("oid" -> (JSONConversions.optional[Int](params.opt("Oid"), 0)))
        
      
      case "CheckNonKYCCounterpartyExistsForGroupCompany" =>
        
          val cache = new DeserialisationHelper
          Map("oid" -> (JSONConversions.optional[Int](params.opt("Oid"), 0)), "groupCompany" -> ((params.opt("GroupCompany")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.GroupCompany.fromJson(o, cache))) }))
        
      
      case "GetCounterpartyForCode" =>
        
          val cache = new DeserialisationHelper
          Map("counterpartyCode" -> (JSONConversions.optional[String](params.opt("CounterpartyCode"), null)))
        
      
      case "GetCounterparties" =>
        
          val cache = new DeserialisationHelper
          Map("includeTemporary" -> (JSONConversions.optional[Boolean](params.opt("IncludeTemporary"), false)))
        
      
      case "GetCounterpartiesForGroupCompany" =>
        
          val cache = new DeserialisationHelper
          Map("company" -> ((params.opt("Company")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.GroupCompany.fromJson(o, cache))) }))
        
      
    }
  }

  def invoke(target: CounterpartyService, operation: String, params: Map[String, Any]): Any = {
    operation match {
      
      case "CreateNonKYCCounterparty" =>
        target.createNonKYCCounterparty(params("nonKYCCounterParty").asInstanceOf[com.trafigura.tradecapture.internal.refinedmetal.NonKYCCounterparty])
      
      case "UpdateNonKYCCounterparty" =>
        target.updateNonKYCCounterparty(params("nonKYCCounterParty").asInstanceOf[com.trafigura.tradecapture.internal.refinedmetal.NonKYCCounterparty])
      
      case "GetNonKYCCounterparty" =>
        target.getNonKYCCounterparty(params("oid").asInstanceOf[Int])
      
      case "CheckNonKYCCounterpartyExists" =>
        target.checkNonKYCCounterpartyExists(params("oid").asInstanceOf[Int])
      
      case "CheckNonKYCCounterpartyExistsForGroupCompany" =>
        target.checkNonKYCCounterpartyExistsForGroupCompany(params("oid").asInstanceOf[Int], params("groupCompany").asInstanceOf[com.trafigura.tradecapture.internal.refinedmetal.GroupCompany])
      
      case "GetCounterpartyForCode" =>
        target.getCounterpartyForCode(params("counterpartyCode").asInstanceOf[String])
      
      case "GetCounterparties" =>
        target.getCounterparties(params("includeTemporary").asInstanceOf[Boolean])
      
      case "GetCounterpartiesForGroupCompany" =>
        target.getCounterpartiesForGroupCompany(params("company").asInstanceOf[com.trafigura.tradecapture.internal.refinedmetal.GroupCompany])
      
    }
  }

  def addResponse(operation:String, jsonResponse:JSONObject, response:Any) = {
    val differentiator = new SerialisationHelper
    operation match {
      
      case "CreateNonKYCCounterparty" =>
        jsonResponse.putOpt("result", response.asInstanceOf[Int])
      
      case "UpdateNonKYCCounterparty" =>
        jsonResponse.putOpt("result", response.asInstanceOf[Boolean])
      
      case "GetNonKYCCounterparty" =>
        jsonResponse.putOpt("result", (response.asInstanceOf[com.trafigura.tradecapture.internal.refinedmetal.NonKYCCounterparty]) match { case null => null; case o => o.toJson(differentiator) })
      
      case "CheckNonKYCCounterpartyExists" =>
        jsonResponse.putOpt("result", response.asInstanceOf[Boolean])
      
      case "CheckNonKYCCounterpartyExistsForGroupCompany" =>
        jsonResponse.putOpt("result", response.asInstanceOf[Boolean])
      
      case "GetCounterpartyForCode" =>
        jsonResponse.putOpt("result", new org.codehaus.jettison.json.JSONArray(if(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.Counterparty]] == null) new java.util.ArrayList() else java.util.Arrays.asList(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.Counterparty]].map(t => (t) match { case null => null; case o => o.toJson(differentiator) }).toArray: _*)))
      
      case "GetCounterparties" =>
        jsonResponse.putOpt("result", new org.codehaus.jettison.json.JSONArray(if(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.Counterparty]] == null) new java.util.ArrayList() else java.util.Arrays.asList(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.Counterparty]].map(t => (t) match { case null => null; case o => o.toJson(differentiator) }).toArray: _*)))
      
      case "GetCounterpartiesForGroupCompany" =>
        jsonResponse.putOpt("result", new org.codehaus.jettison.json.JSONArray(if(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.Counterparty]] == null) new java.util.ArrayList() else java.util.Arrays.asList(response.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.Counterparty]].map(t => (t) match { case null => null; case o => o.toJson(differentiator) }).toArray: _*)))
      
    }
  }

  
  def serializeCreateNonKYCCounterparty(nonKYCCounterParty: com.trafigura.tradecapture.internal.refinedmetal.NonKYCCounterparty): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("NonKYCCounterParty", (nonKYCCounterParty) match { case null => null; case o => o.toJson(differentiator) })
    
    params
  }
  
  def serializeUpdateNonKYCCounterparty(nonKYCCounterParty: com.trafigura.tradecapture.internal.refinedmetal.NonKYCCounterparty): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("NonKYCCounterParty", (nonKYCCounterParty) match { case null => null; case o => o.toJson(differentiator) })
    
    params
  }
  
  def serializeGetNonKYCCounterparty(oid: Int): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("Oid", oid)
    
    params
  }
  
  def serializeCheckNonKYCCounterpartyExists(oid: Int): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("Oid", oid)
    
    params
  }
  
  def serializeCheckNonKYCCounterpartyExistsForGroupCompany(oid: Int, groupCompany: com.trafigura.tradecapture.internal.refinedmetal.GroupCompany): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("Oid", oid)
    
      params.putOpt("GroupCompany", (groupCompany) match { case null => null; case o => o.toJson(differentiator) })
    
    params
  }
  
  def serializeGetCounterpartyForCode(counterpartyCode: String): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("CounterpartyCode", counterpartyCode)
    
    params
  }
  
  def serializeGetCounterparties(includeTemporary: Boolean): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("IncludeTemporary", includeTemporary)
    
    params
  }
  
  def serializeGetCounterpartiesForGroupCompany(company: com.trafigura.tradecapture.internal.refinedmetal.GroupCompany): JSONObject = {
    val differentiator = new SerialisationHelper
    val params = new JSONObject
    
      params.putOpt("Company", (company) match { case null => null; case o => o.toJson(differentiator) })
    
    params
  }
  

  class Proxy(val handler: (String, JSONObject) => JSONObject) extends CounterpartyService {
  
    def createNonKYCCounterparty(nonKYCCounterParty: com.trafigura.tradecapture.internal.refinedmetal.NonKYCCounterparty): Int = {
        val request = new JSONObject
        request.put("method", "CreateNonKYCCounterparty")
        
        request.put("params", serializeCreateNonKYCCounterparty(nonKYCCounterParty))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[Int]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optional[Int](response.opt("result"), 0)
        }
    }
  
    def updateNonKYCCounterparty(nonKYCCounterParty: com.trafigura.tradecapture.internal.refinedmetal.NonKYCCounterparty): Boolean = {
        val request = new JSONObject
        request.put("method", "UpdateNonKYCCounterparty")
        
        request.put("params", serializeUpdateNonKYCCounterparty(nonKYCCounterParty))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[Boolean]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optional[Boolean](response.opt("result"), false)
        }
    }
  
    def getNonKYCCounterparty(oid: Int): com.trafigura.tradecapture.internal.refinedmetal.NonKYCCounterparty = {
        val request = new JSONObject
        request.put("method", "GetNonKYCCounterparty")
        
        request.put("params", serializeGetNonKYCCounterparty(oid))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[com.trafigura.tradecapture.internal.refinedmetal.NonKYCCounterparty]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          (response.opt("result")) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.NonKYCCounterparty.fromJson(o, cache))) }
        }
    }
  
    def checkNonKYCCounterpartyExists(oid: Int): Boolean = {
        val request = new JSONObject
        request.put("method", "CheckNonKYCCounterpartyExists")
        
        request.put("params", serializeCheckNonKYCCounterpartyExists(oid))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[Boolean]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optional[Boolean](response.opt("result"), false)
        }
    }
  
    def checkNonKYCCounterpartyExistsForGroupCompany(oid: Int, groupCompany: com.trafigura.tradecapture.internal.refinedmetal.GroupCompany): Boolean = {
        val request = new JSONObject
        request.put("method", "CheckNonKYCCounterpartyExistsForGroupCompany")
        
        request.put("params", serializeCheckNonKYCCounterpartyExistsForGroupCompany(oid, groupCompany))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[Boolean]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optional[Boolean](response.opt("result"), false)
        }
    }
  
    def getCounterpartyForCode(counterpartyCode: String): List[com.trafigura.tradecapture.internal.refinedmetal.Counterparty] = {
        val request = new JSONObject
        request.put("method", "GetCounterpartyForCode")
        
        request.put("params", serializeGetCounterpartyForCode(counterpartyCode))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.Counterparty]]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(response.opt("result"), x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.Counterparty.fromJson(o, cache))) })
        }
    }
  
    def getCounterparties(includeTemporary: Boolean): List[com.trafigura.tradecapture.internal.refinedmetal.Counterparty] = {
        val request = new JSONObject
        request.put("method", "GetCounterparties")
        
        request.put("params", serializeGetCounterparties(includeTemporary))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.Counterparty]]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(response.opt("result"), x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.Counterparty.fromJson(o, cache))) })
        }
    }
  
    def getCounterpartiesForGroupCompany(company: com.trafigura.tradecapture.internal.refinedmetal.GroupCompany): List[com.trafigura.tradecapture.internal.refinedmetal.Counterparty] = {
        val request = new JSONObject
        request.put("method", "GetCounterpartiesForGroupCompany")
        
        request.put("params", serializeGetCounterpartiesForGroupCompany(company))
        
        var routing = null
        val response = handler(routing, request)
        if (response == null) {
          null.asInstanceOf[List[com.trafigura.tradecapture.internal.refinedmetal.Counterparty]]   // Doesn't work well with primitive types, but we should only see null in cases like discover anyway
        } else {
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(response.opt("result"), x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.Counterparty.fromJson(o, cache))) })
        }
    }
  
  }
}

