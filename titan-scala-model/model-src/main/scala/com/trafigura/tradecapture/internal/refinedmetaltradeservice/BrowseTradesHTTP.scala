/**
 * WARNING: This file was automatically generated by the Trading Hub tooling version 2.15.
 * Any manual changes may be overwritten and lost!
 */


// Generated from model_service_http.rb

package com.trafigura.tradecapture.internal.refinedmetaltradeservice

import com.trafigura.tradecapture.internal.refinedmetal._
import com.trafigura.tradecapture.internal.refinedmetaltradeservice._
import com.trafigura.edm.shared.types._

import org.codehaus.jettison.json.JSONObject
import com.trafigura.tradinghub.support._
import javax.ws.rs._
import javax.ws.rs.core.Response
import org.jboss.resteasy.client.ClientResponse
import org.jboss.resteasy.annotations._
import scala.collection.JavaConversions._

// Some of the objects from the system namespace responses are
// used in handwritten code, so this hybrid resolution is required.
import com.trafigura.responses._


// JAX-RS support for BrowseTrades


// A resource trait corresponding to BrowseTrades

@Path("/BrowseTrades")
trait BrowseTradesResource {
  
  @Path("GetTradeBlotterRowById")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getTradeBlotterRowById(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetTradeBlotterRowByTitanId")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getTradeBlotterRowByTitanId(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetFilteredTradeBlotterRowById")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getFilteredTradeBlotterRowById(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetFilteredTradeBlotterRowByTitanId")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getFilteredTradeBlotterRowByTitanId(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetNotCancelledTradeBlotterRows")
  @POST  @Produces(Array("application/json"))
  def getNotCancelledTradeBlotterRows(@HeaderParam("User") _userHeader:String): Response
  
  @Path("GetNotCancelledTradeBlotterRowsFromId")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getNotCancelledTradeBlotterRowsFromId(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetNotCancelledTradeBlotterRowsFromTitanId")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getNotCancelledTradeBlotterRowsFromTitanId(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetFilteredNotCancelledTradeBlotterRowsFromId")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getFilteredNotCancelledTradeBlotterRowsFromId(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetFilteredNotCancelledTradeBlotterRowsFromTitanId")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getFilteredNotCancelledTradeBlotterRowsFromTitanId(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetTradeBlotterQuotaRowsForTrade")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getTradeBlotterQuotaRowsForTrade(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetTradeBlotterQuotaRowsForTradeByTitanId")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getTradeBlotterQuotaRowsForTradeByTitanId(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("CheckTradeWithIdExists")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def checkTradeWithIdExists(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("CheckTradeWithTitanIdExists")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def checkTradeWithTitanIdExists(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("CheckTradeWithNeptuneIdExists")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def checkTradeWithNeptuneIdExists(@HeaderParam("User") _userHeader:String, in: String): Response
  
}


// Wrap a BrowseTradesResource (provided by RESTEasy's client
// support) as a BrowseTrades
//
// Note: will throw an exception on parse/status code errors, exception will contain details of the error
//
class BrowseTradesResourceProxy(val resource: BrowseTradesResource) extends BrowseTrades {

  val log = org.slf4j.LoggerFactory.getLogger(this.getClass.getName)

  
  def getTradeBlotterRowById(oid: Int) = getTradeBlotterRowById(oid,null)
  def getTradeBlotterRowById(oid: Int, securityContext:SecurityContext = null): com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getTradeBlotterRowById(_userHeader, BrowseTradesJSON.serializeGetTradeBlotterRowById(oid).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getTradeBlotterRowById: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) }
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getTradeBlotterRowByTitanId(titanId: com.trafigura.edm.shared.types.TitanId) = getTradeBlotterRowByTitanId(titanId,null)
  def getTradeBlotterRowByTitanId(titanId: com.trafigura.edm.shared.types.TitanId, securityContext:SecurityContext = null): com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getTradeBlotterRowByTitanId(_userHeader, BrowseTradesJSON.serializeGetTradeBlotterRowByTitanId(titanId).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getTradeBlotterRowByTitanId: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) }
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getFilteredTradeBlotterRowById(filterByWho: Int, filterByDate: Int, oid: Int) = getFilteredTradeBlotterRowById(filterByWho, filterByDate, oid,null)
  def getFilteredTradeBlotterRowById(filterByWho: Int, filterByDate: Int, oid: Int, securityContext:SecurityContext = null): com.trafigura.tradecapture.internal.refinedmetaltradeservice.FilteredTradeBlotterRowResults = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getFilteredTradeBlotterRowById(_userHeader, BrowseTradesJSON.serializeGetFilteredTradeBlotterRowById(filterByWho, filterByDate, oid).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getFilteredTradeBlotterRowById: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetaltradeservice.FilteredTradeBlotterRowResults.fromJson(o, cache))) }
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getFilteredTradeBlotterRowByTitanId(filterByWho: Int, filterByDate: Int, titanId: com.trafigura.edm.shared.types.TitanId) = getFilteredTradeBlotterRowByTitanId(filterByWho, filterByDate, titanId,null)
  def getFilteredTradeBlotterRowByTitanId(filterByWho: Int, filterByDate: Int, titanId: com.trafigura.edm.shared.types.TitanId, securityContext:SecurityContext = null): com.trafigura.tradecapture.internal.refinedmetaltradeservice.FilteredTradeBlotterRowResults = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getFilteredTradeBlotterRowByTitanId(_userHeader, BrowseTradesJSON.serializeGetFilteredTradeBlotterRowByTitanId(filterByWho, filterByDate, titanId).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getFilteredTradeBlotterRowByTitanId: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetaltradeservice.FilteredTradeBlotterRowResults.fromJson(o, cache))) }
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getNotCancelledTradeBlotterRows() = getNotCancelledTradeBlotterRows(null)
  def getNotCancelledTradeBlotterRows( securityContext:SecurityContext = null): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow] = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getNotCancelledTradeBlotterRows(_userHeader)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getNotCancelledTradeBlotterRows: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(obj, x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) })
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getNotCancelledTradeBlotterRowsFromId(identifier: Int, count: Int) = getNotCancelledTradeBlotterRowsFromId(identifier, count,null)
  def getNotCancelledTradeBlotterRowsFromId(identifier: Int, count: Int, securityContext:SecurityContext = null): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow] = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getNotCancelledTradeBlotterRowsFromId(_userHeader, BrowseTradesJSON.serializeGetNotCancelledTradeBlotterRowsFromId(identifier, count).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getNotCancelledTradeBlotterRowsFromId: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(obj, x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) })
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getNotCancelledTradeBlotterRowsFromTitanId(titanId: com.trafigura.edm.shared.types.TitanId, count: Int) = getNotCancelledTradeBlotterRowsFromTitanId(titanId, count,null)
  def getNotCancelledTradeBlotterRowsFromTitanId(titanId: com.trafigura.edm.shared.types.TitanId, count: Int, securityContext:SecurityContext = null): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow] = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getNotCancelledTradeBlotterRowsFromTitanId(_userHeader, BrowseTradesJSON.serializeGetNotCancelledTradeBlotterRowsFromTitanId(titanId, count).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getNotCancelledTradeBlotterRowsFromTitanId: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(obj, x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) })
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getFilteredNotCancelledTradeBlotterRowsFromId(filterByWho: Int, filterByDate: Int, identifier: Int, count: Int) = getFilteredNotCancelledTradeBlotterRowsFromId(filterByWho, filterByDate, identifier, count,null)
  def getFilteredNotCancelledTradeBlotterRowsFromId(filterByWho: Int, filterByDate: Int, identifier: Int, count: Int, securityContext:SecurityContext = null): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow] = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getFilteredNotCancelledTradeBlotterRowsFromId(_userHeader, BrowseTradesJSON.serializeGetFilteredNotCancelledTradeBlotterRowsFromId(filterByWho, filterByDate, identifier, count).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getFilteredNotCancelledTradeBlotterRowsFromId: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(obj, x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) })
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getFilteredNotCancelledTradeBlotterRowsFromTitanId(filterByWho: Int, filterByDate: Int, titanId: com.trafigura.edm.shared.types.TitanId, count: Int) = getFilteredNotCancelledTradeBlotterRowsFromTitanId(filterByWho, filterByDate, titanId, count,null)
  def getFilteredNotCancelledTradeBlotterRowsFromTitanId(filterByWho: Int, filterByDate: Int, titanId: com.trafigura.edm.shared.types.TitanId, count: Int, securityContext:SecurityContext = null): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow] = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getFilteredNotCancelledTradeBlotterRowsFromTitanId(_userHeader, BrowseTradesJSON.serializeGetFilteredNotCancelledTradeBlotterRowsFromTitanId(filterByWho, filterByDate, titanId, count).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getFilteredNotCancelledTradeBlotterRowsFromTitanId: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(obj, x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterRow.fromJson(o, cache))) })
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getTradeBlotterQuotaRowsForTrade(oid: Int, sortBy: String) = getTradeBlotterQuotaRowsForTrade(oid, sortBy,null)
  def getTradeBlotterQuotaRowsForTrade(oid: Int, sortBy: String, securityContext:SecurityContext = null): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow] = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getTradeBlotterQuotaRowsForTrade(_userHeader, BrowseTradesJSON.serializeGetTradeBlotterQuotaRowsForTrade(oid, sortBy).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getTradeBlotterQuotaRowsForTrade: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(obj, x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow.fromJson(o, cache))) })
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getTradeBlotterQuotaRowsForTradeByTitanId(titanId: com.trafigura.edm.shared.types.TitanId, sortBy: String) = getTradeBlotterQuotaRowsForTradeByTitanId(titanId, sortBy,null)
  def getTradeBlotterQuotaRowsForTradeByTitanId(titanId: com.trafigura.edm.shared.types.TitanId, sortBy: String, securityContext:SecurityContext = null): List[com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow] = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getTradeBlotterQuotaRowsForTradeByTitanId(_userHeader, BrowseTradesJSON.serializeGetTradeBlotterQuotaRowsForTradeByTitanId(titanId, sortBy).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getTradeBlotterQuotaRowsForTradeByTitanId: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(obj, x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.refinedmetal.TradeBlotterQuotaRow.fromJson(o, cache))) })
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def checkTradeWithIdExists(oid: Int) = checkTradeWithIdExists(oid,null)
  def checkTradeWithIdExists(oid: Int, securityContext:SecurityContext = null): Boolean = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.checkTradeWithIdExists(_userHeader, BrowseTradesJSON.serializeCheckTradeWithIdExists(oid).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to checkTradeWithIdExists: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optional[Boolean](obj, false)
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def checkTradeWithTitanIdExists(titanId: com.trafigura.edm.shared.types.TitanId) = checkTradeWithTitanIdExists(titanId,null)
  def checkTradeWithTitanIdExists(titanId: com.trafigura.edm.shared.types.TitanId, securityContext:SecurityContext = null): Boolean = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.checkTradeWithTitanIdExists(_userHeader, BrowseTradesJSON.serializeCheckTradeWithTitanIdExists(titanId).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to checkTradeWithTitanIdExists: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optional[Boolean](obj, false)
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def checkTradeWithNeptuneIdExists(neptuneId: String) = checkTradeWithNeptuneIdExists(neptuneId,null)
  def checkTradeWithNeptuneIdExists(neptuneId: String, securityContext:SecurityContext = null): Boolean = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.checkTradeWithNeptuneIdExists(_userHeader, BrowseTradesJSON.serializeCheckTradeWithNeptuneIdExists(neptuneId).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to checkTradeWithNeptuneIdExists: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optional[Boolean](obj, false)
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
}

// Wrap a BrowseTrades as a BrowseTradesResource (e.g. to be
// exposed by a JAX-RS implementation).

class BrowseTradesResourceStub(val target: BrowseTrades, filters: java.util.List[ServiceFilter])
    extends AbstractResourceStub(filters)
    with BrowseTradesResource {

  def this(target: BrowseTrades) = this(target, new java.util.ArrayList[ServiceFilter])

  requireFilters("com.trafigura.tradinghub.support.PermissionFilter","com.trafigura.services.security.ServiceOperationFilterBase")

  
  def getTradeBlotterRowById(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "GetTradeBlotterRowById", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getTradeBlotterRowByTitanId(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "GetTradeBlotterRowByTitanId", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getFilteredTradeBlotterRowById(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "GetFilteredTradeBlotterRowById", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getFilteredTradeBlotterRowByTitanId(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "GetFilteredTradeBlotterRowByTitanId", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getNotCancelledTradeBlotterRows(_userHeader:String): Response = {

    try {
    val params = new JSONObject()
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "GetNotCancelledTradeBlotterRows", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getNotCancelledTradeBlotterRowsFromId(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "GetNotCancelledTradeBlotterRowsFromId", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getNotCancelledTradeBlotterRowsFromTitanId(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "GetNotCancelledTradeBlotterRowsFromTitanId", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getFilteredNotCancelledTradeBlotterRowsFromId(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "GetFilteredNotCancelledTradeBlotterRowsFromId", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getFilteredNotCancelledTradeBlotterRowsFromTitanId(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "GetFilteredNotCancelledTradeBlotterRowsFromTitanId", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getTradeBlotterQuotaRowsForTrade(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "GetTradeBlotterQuotaRowsForTrade", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getTradeBlotterQuotaRowsForTradeByTitanId(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "GetTradeBlotterQuotaRowsForTradeByTitanId", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def checkTradeWithIdExists(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "CheckTradeWithIdExists", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def checkTradeWithTitanIdExists(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "CheckTradeWithTitanIdExists", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def checkTradeWithNeptuneIdExists(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      BrowseTradesJSON.dispatch(target, filters.toSeq, "CheckTradeWithNeptuneIdExists", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
}
