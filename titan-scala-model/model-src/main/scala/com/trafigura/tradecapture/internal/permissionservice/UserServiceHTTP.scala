/**
 * WARNING: This file was automatically generated by the Trading Hub tooling version 2.15.
 * Any manual changes may be overwritten and lost!
 */


// Generated from model_service_http.rb

package com.trafigura.tradecapture.internal.permissionservice

import com.trafigura.tradecapture.internal.permissionservice._

import org.codehaus.jettison.json.JSONObject
import com.trafigura.tradinghub.support._
import javax.ws.rs._
import javax.ws.rs.core.Response
import org.jboss.resteasy.client.ClientResponse
import org.jboss.resteasy.annotations._
import scala.collection.JavaConversions._

// Some of the objects from the system namespace responses are
// used in handwritten code, so this hybrid resolution is required.
import com.trafigura.responses._


// JAX-RS support for UserService


// A resource trait corresponding to UserService

@Path("/UserService")
trait UserServiceResource {
  
  @Path("Create")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def create(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetBySid")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getBySid(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetByUserId")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getByUserId(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("Get")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def get(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("TryGet")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def tryGet(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetAll")
  @POST  @Produces(Array("application/json"))
  def getAll(@HeaderParam("User") _userHeader:String): Response
  
  @Path("Update")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def update(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("Delete")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def delete(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("AddRole")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def addRole(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("RemoveRole")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def removeRole(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetUserRoles")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getUserRoles(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetUserGroups")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getUserGroups(@HeaderParam("User") _userHeader:String, in: String): Response
  
  @Path("GetUserGroupRoles")
  @POST @Consumes(Array("application/json")) @Produces(Array("application/json"))
  def getUserGroupRoles(@HeaderParam("User") _userHeader:String, in: String): Response
  
}


// Wrap a UserServiceResource (provided by RESTEasy's client
// support) as a UserService
//
// Note: will throw an exception on parse/status code errors, exception will contain details of the error
//
class UserServiceResourceProxy(val resource: UserServiceResource) extends UserService {

  val log = org.slf4j.LoggerFactory.getLogger(this.getClass.getName)

  
  def create(user: com.trafigura.tradecapture.internal.permissionservice.User) = create(user,null)
  def create(user: com.trafigura.tradecapture.internal.permissionservice.User, securityContext:SecurityContext = null): com.trafigura.tradecapture.internal.permissionservice.PermissionResult = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.create(_userHeader, UserServiceJSON.serializeCreate(user).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to create: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.permissionservice.PermissionResult.fromJson(o, cache))) }
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getBySid(sid: String) = getBySid(sid,null)
  def getBySid(sid: String, securityContext:SecurityContext = null): com.trafigura.tradecapture.internal.permissionservice.User = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getBySid(_userHeader, UserServiceJSON.serializeGetBySid(sid).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getBySid: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.permissionservice.User.fromJson(o, cache))) }
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getByUserId(userId: com.trafigura.tradecapture.internal.permissionservice.UserId) = getByUserId(userId,null)
  def getByUserId(userId: com.trafigura.tradecapture.internal.permissionservice.UserId, securityContext:SecurityContext = null): com.trafigura.tradecapture.internal.permissionservice.User = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getByUserId(_userHeader, UserServiceJSON.serializeGetByUserId(userId).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getByUserId: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.permissionservice.User.fromJson(o, cache))) }
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def get(oid: Int) = get(oid,null)
  def get(oid: Int, securityContext:SecurityContext = null): com.trafigura.tradecapture.internal.permissionservice.User = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.get(_userHeader, UserServiceJSON.serializeGet(oid).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to get: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.permissionservice.User.fromJson(o, cache))) }
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def tryGet(oid: Int) = tryGet(oid,null)
  def tryGet(oid: Int, securityContext:SecurityContext = null): List[com.trafigura.tradecapture.internal.permissionservice.User] = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.tryGet(_userHeader, UserServiceJSON.serializeTryGet(oid).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to tryGet: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(obj, x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.permissionservice.User.fromJson(o, cache))) })
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getAll() = getAll(null)
  def getAll( securityContext:SecurityContext = null): List[com.trafigura.tradecapture.internal.permissionservice.User] = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getAll(_userHeader)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getAll: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(obj, x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.permissionservice.User.fromJson(o, cache))) })
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def update(user: com.trafigura.tradecapture.internal.permissionservice.User) = update(user,null)
  def update(user: com.trafigura.tradecapture.internal.permissionservice.User, securityContext:SecurityContext = null): com.trafigura.tradecapture.internal.permissionservice.PermissionResult = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.update(_userHeader, UserServiceJSON.serializeUpdate(user).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to update: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.permissionservice.PermissionResult.fromJson(o, cache))) }
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def delete(oid: Int) = delete(oid,null)
  def delete(oid: Int, securityContext:SecurityContext = null): Boolean = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.delete(_userHeader, UserServiceJSON.serializeDelete(oid).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to delete: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optional[Boolean](obj, false)
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def addRole(userOid: Int, roleOid: Int) = addRole(userOid, roleOid,null)
  def addRole(userOid: Int, roleOid: Int, securityContext:SecurityContext = null): Boolean = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.addRole(_userHeader, UserServiceJSON.serializeAddRole(userOid, roleOid).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to addRole: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optional[Boolean](obj, false)
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def removeRole(userOid: Int, roleOid: Int) = removeRole(userOid, roleOid,null)
  def removeRole(userOid: Int, roleOid: Int, securityContext:SecurityContext = null): Boolean = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.removeRole(_userHeader, UserServiceJSON.serializeRemoveRole(userOid, roleOid).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to removeRole: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optional[Boolean](obj, false)
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getUserRoles(oid: Int) = getUserRoles(oid,null)
  def getUserRoles(oid: Int, securityContext:SecurityContext = null): List[com.trafigura.tradecapture.internal.permissionservice.Role] = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getUserRoles(_userHeader, UserServiceJSON.serializeGetUserRoles(oid).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getUserRoles: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(obj, x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.permissionservice.Role.fromJson(o, cache))) })
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getUserGroups(oid: Int) = getUserGroups(oid,null)
  def getUserGroups(oid: Int, securityContext:SecurityContext = null): List[com.trafigura.tradecapture.internal.permissionservice.Group] = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getUserGroups(_userHeader, UserServiceJSON.serializeGetUserGroups(oid).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getUserGroups: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(obj, x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.permissionservice.Group.fromJson(o, cache))) })
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
  def getUserGroupRoles(oid: Int) = getUserGroupRoles(oid,null)
  def getUserGroupRoles(oid: Int, securityContext:SecurityContext = null): List[com.trafigura.tradecapture.internal.permissionservice.Role] = {
    val _userHeader = if (securityContext != null) { securityContext.user } else { null }
    val response = resource.getUserGroupRoles(_userHeader, UserServiceJSON.serializeGetUserGroupRoles(oid).toString)
    val content = response.asInstanceOf[ClientResponse[String]].getEntity(classOf[String])

    log.debug("Completed call to getUserGroupRoles: " + response.getStatus() + " - " + content)

    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
      
	      try {
          val obj = JSONConversions.parseJSON(content)
          val cache = new DeserialisationHelper
          JSONConversions.optionalList(obj, x => (x) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => cache.objectFor(o).getOrElse(cache.seen(o, com.trafigura.tradecapture.internal.permissionservice.Role.fromJson(o, cache))) })
	      } catch {
          case ex : Exception => {
            log.error("Parse exception from Status-Code: " + response.getStatus() + " on content: " + content + "; throwing exception...", ex)
            throw new Exception("Service invocation, response parse exception: Status Code: " + response.getStatus() + ", Content: '" + content + "'")
          }
        }
      
    }
    else { // non OK 200 status response
      log.debug("status NOT OK 200, throwing exception...")

      val obj = JSONConversions.parseJSON(content)

      val err = (obj) match { case null => null; case o: org.codehaus.jettison.json.JSONObject => Result.fromJson(o, new DeserialisationHelper) }
        err match {
          case er : Result => {
            log.error("error response: " + er.message  + " { " + er.toString + " } status: " + response.getStatus)
            val ex = new Exception(er.message  + " { " + er.toString + " } status: " + response.getStatus)
            //ex.setStackTrace(er.stackTrace) // todo, need to add server stack trace, probably to customer application exception class
            throw ex
          }
          case _ => {
            log.error("unknown response, not an error response, content: " + content)
            throw new Exception("Unhandled response received, content: " + content)
          }
        }
    }
  }
  
}

// Wrap a UserService as a UserServiceResource (e.g. to be
// exposed by a JAX-RS implementation).

class UserServiceResourceStub(val target: UserService, filters: java.util.List[ServiceFilter])
    extends AbstractResourceStub(filters)
    with UserServiceResource {

  def this(target: UserService) = this(target, new java.util.ArrayList[ServiceFilter])

  requireFilters("com.trafigura.tradinghub.support.PermissionFilter","com.trafigura.services.security.ServiceOperationFilterBase")

  
  def create(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "Create", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getBySid(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "GetBySid", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getByUserId(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "GetByUserId", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def get(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "Get", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def tryGet(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "TryGet", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getAll(_userHeader:String): Response = {

    try {
    val params = new JSONObject()
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "GetAll", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def update(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "Update", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def delete(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "Delete", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def addRole(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "AddRole", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def removeRole(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "RemoveRole", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getUserRoles(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "GetUserRoles", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getUserGroups(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "GetUserGroups", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
  def getUserGroupRoles(_userHeader:String, in: String): Response = {

    try {
    val params = new JSONObject(in)
     val res = 
      UserServiceJSON.dispatch(target, filters.toSeq, "GetUserGroupRoles", params, buildSecurityContext(_userHeader))

    
    Response.ok(JSONConversions.stringifyJSON(res.opt("result"))).build
    
    } catch {
      case ex:Throwable => generateErrorEntity(ex)
    }
  }
  
}
