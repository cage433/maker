package starling.maths

import org.scalatest.testng.TestNGSuite
import cern.colt.matrix.{DoubleMatrix1D => Vector, DoubleMatrix2D => Matrix, DoubleFactory2D}
import cern.colt.matrix.impl.{DenseDoubleMatrix1D => DVector, DenseDoubleMatrix2D => DMatrix}
import starling.utils.conversions.RichColtMatrices._
import org.testng.annotations._
import org.testng.Assert._
import starling.utils.ScalaTestUtils._
import java.lang.Math._
import starling.utils.Log

/** Various tests to ensure that the shifts generated by PriceShiftGenerator satisfy the
 * 	necessary statistics
 */
class PriceShiftGeneratorTests extends TestNGSuite {

  
  private def produceRandomShifts(psg : PriceShiftGenerator, nScenarios : Int) : Matrix = {
  	var results = new DMatrix(nScenarios, psg.nRiskFactors)
    for (iScenario <- 0 until nScenarios){
      results.viewRow(iScenario).assign(psg.nextShifts)
    }
    results
  }
  
  private def randomMeansAndVols(seed : Int) : (Array[Double], Array[Double], Double) = {
    val su = RandomVariables.standardUniform(seed)
    val nPrices = 1 + (20 * su.nextDouble).asInstanceOf[Int]
    val prices = (new DVector(nPrices).assign(su) * 100.0).toArray
    val vols = (new DVector(nPrices).assign(su)).toArray
    val dT = 3.0 * su.nextDouble
    (prices, vols, dT)
  }
  
  @DataProvider(name = "TestConvergenceSupplier")
  def testConvergenceSupplier = {
     constructArgs(
      (Array(90.0), Array(0.5), 0.5)
      ,(Array(90.0, 10.0), Array(0.5, 0.3), 5.0)
      ,(Array(90.0, 10.0, 33.0, 45.0, 1.3), Array(0.5, 0.3, 0.2, 0.9, 0.7), 1.5)
      ,randomMeansAndVols(12345)
      ,randomMeansAndVols(123456)
      ,randomMeansAndVols(123)
    )
  }
  @Test(dataProvider = "TestConvergenceSupplier")
  /**
   * Test that the shifts produced exhibit the expected means
   */
  def testMeanConverges(prices : Array[Double], vols : Array[Double], dT : Double){
    val nPrices = prices.size
    val rhoMatrix = RandomCorrelationMatrix(nPrices, 321321)
  	val psg = PriceShiftGenerator(new DVector(prices), new DVector(vols), rhoMatrix, dT, 12345)
    val nScenarios = 1000
  	val results = produceRandomShifts(psg, nScenarios)

  	for (iPrice <- 0 until nPrices){
      val sampleMean = results.viewColumn(iPrice).mean
      val standardError = results.viewColumn(iPrice).standardError
      assertEquals(sampleMean, 0.0, 3.0 * standardError, "Should be no more than " + (3.0 * standardError))
    }
  }

  private def annualisedLogReturns(shifts : Matrix, prices : Array[Double], dT : Double) : Matrix = {
    val m = shifts.like
    for (iPrice <- 0 until shifts.columns){
  	  val shiftedPrices = shifts.viewColumn(iPrice) + prices(iPrice) 
  	  val logReturns = (shiftedPrices / prices(iPrice)).log / sqrt(dT)
  	  m.viewColumn(iPrice).assign(logReturns.copy)
    }
    m
  }
  @Test(dataProvider = "TestConvergenceSupplier")
  /**
   * Test that the shifts produced exhibit the expected volatilities
   */
  def testVolConverges(prices : Array[Double], vols : Array[Double], dT : Double){
    val nPrices = prices.size
    val randomSeed = 54321
    val rhoMatrix = RandomCorrelationMatrix(nPrices, 321321)
  	val psg = PriceShiftGenerator(
  	  new DVector(prices), new DVector(vols),
  	  rhoMatrix,
     dT, randomSeed
  	)
    val nScenarios = 5000
  	val shifts = produceRandomShifts(psg, nScenarios)
  	val logReturns = annualisedLogReturns(shifts, prices, dT)
  	for (iPrice <- 0 until nPrices){
  	  val sampleVol = logReturns.viewColumn(iPrice).standardDeviation
      assertEquals(sampleVol, vols(iPrice), vols(iPrice) * 0.04)
    }
  }

  @Test(dataProvider = "TestConvergenceSupplier")
  /**
   * Test that the shifts produced exhibit the expected correlations
   */
  def testRhoConverges(prices : Array[Double], vols : Array[Double], dT : Double){
    val nPrices = prices.size
    val randomSeed = 54321
    val rhoMatrix = RandomCorrelationMatrix(nPrices, 321321)
  	val psg = PriceShiftGenerator(
  	  new DVector(prices), new DVector(vols),
  	  rhoMatrix,
     dT, randomSeed
  	)
    val nScenarios = 5000
  	val shifts = produceRandomShifts(psg, nScenarios)
  	val logReturns = annualisedLogReturns(shifts, prices, dT)
    for (iPrice <- 0 until nPrices){
      Log.info("St DEV = " + logReturns(iPrice).standardDeviation + ", expected " + vols(iPrice) * math.sqrt(dT))
      val tol = 3.0 * vols(iPrice) * math.sqrt(dT) / math.sqrt(nScenarios)
//      assertEquals(logReturns.viewColumn(iPrice).mean, 0.0, tol)
    }
  	for {
  	  iPrice <- 0 until nPrices
  	  jPrice <- 0 until nPrices
  	  if iPrice != jPrice
     }{
  	  val sampleRho = logReturns.viewColumn(iPrice).correlation(logReturns.viewColumn(jPrice))
      assertEquals(sampleRho, rhoMatrix(iPrice, jPrice), 0.05)
    }
  }
}
