import sbt._
import sbt.Process._
import Project._
import Path._

trait ModelSourceGeneratingProject extends BasicScalaProject with MavenStyleScalaPaths {

  // Source generated by the model goes here
  protected lazy val modelMainScalaSourcePath = "model-src" / "main" / "scala"
  protected lazy val modelTestScalaSourcePath = "model-src" / "test" / "scala"

  // Add the generated code to the source paths
  override def mainSourceRoots = super.mainSourceRoots +++ modelMainScalaSourcePath
  override def testSourceRoots = super.testSourceRoots +++ modelTestScalaSourcePath

  // implement this with the source(s) of any ruby code used to generate the model
  def rubyModelPathFinder : PathFinder

  // cleaning must also remove any model source and any copied to the combined directory
  protected def cleanPath(path : Path) = {
    FileUtilities.clean(path, new ConsoleLogger())
    None
  }

  protected lazy val cleanModelMainSource = task {cleanPath(modelMainScalaSourcePath)}
  protected lazy val cleanModelTestSource = task {cleanPath(modelTestScalaSourcePath)}
  override def cleanAction = super.cleanAction dependsOn(
    cleanModelMainSource, cleanModelTestSource
  )

  // Ensure model source is generated before compilation
  override def compileAction = super.compileAction dependsOn(generateModelMainSource)
  override def testCompileAction = super.testCompileAction dependsOn(generateModelTestSource)
    

  protected def generateModelSource(
    modelSourcePath : Path, 
    cmdOrNone : Option[java.lang.ProcessBuilder]
  )  = task {

    def latestRubyFileTime = {
      val files = rubyModelPathFinder.getFiles
      if (files.isEmpty)
        throw new Exception("No ruby files found")
      files.map(_.lastModified).toList.sort(_>_).head
    }
    
    def earliestScalaFileTime = {
      (modelSourcePath ** "*.scala").getFiles.toList.map(_.lastModified).sort(_<_) match {
        case Nil => None
        case t :: _ => Some(t)
      }
    }
    def doGeneration = {
      cleanPath(modelSourcePath)
      cmdOrNone match {
        case Some(cmd) => cmd !;
        case None => 0
      }
    }

    // Only call the command if there are no Scala source files, or else if any Ruby file has changed
    val result = (latestRubyFileTime, earliestScalaFileTime) match {
      case (_, None) => doGeneration
      case (r, Some(s)) if r > s => doGeneration
      case _ => 0
    }
    
    if (result == 0)
      None
    else
      Some("bad things happened when building the model")
  }

  // implement the collands to generate the model source
  protected def generateModelMainSourceCmd : Option[java.lang.ProcessBuilder] = None
  protected def generateModelTestSourceCmd : Option[java.lang.ProcessBuilder] = None

  protected lazy val generateModelMainSource = generateModelSource(modelMainScalaSourcePath, generateModelMainSourceCmd)
  protected lazy val generateModelTestSource = generateModelSource(modelTestScalaSourcePath, generateModelTestSourceCmd)

}

